---
title: Arroyo SQL
description: 'Guide to Arroyo SQL'
---

Currently the primary method of producing an Arroyo pipeline is through the SQL API. 
In stream processing it is common to treat infinite streams as tables, albeit unbounded tablels.
Arroyo's SQL mainly complies with standard Postgres SQL.
However, there are a few extensions as well as some limitations.

## DataFusion

Arroyo leverages the [Apache DataFusion](https://github.com/apache/arrow-datafusion) library for parsing and planning SQL.
DataFusion is part of the Apache Arrow ecosystem and provides a full SQL compute engine. 
Because the parsing and planning APIs of DataFusion are public, 
it can also be used for mapping SQL statements into another compute engine, such as Arroyo.
 
## Data Types
Arroyo defines its schemas using the primitive types below. 
These are each in turn represented by in the dataflow as Rust types.
The table also includes the Arrow types that are planned against by DataFusion
and the SQL types that are used in the SQL API.

| Arroyo type | Rust Type | Arrow DataType| Sql Types  |
| ----------- | -----------|--|-|
| Boolean     |bool| Boolean | BOOLEAN|
| Int32       |i32| Int32 | INT, INTEGER|
| Int64       | i64|Int64 | BIGINT|
|Uint32       | u32|UInt32| INT UNSIGNED, INTEGER UNSIGNED|
|Uint64       | u64| UInt64| BIGINT UNSIGNED|
|Float32      | f32|Float32| FLOAT, REAL      |
|Float64      | f64|Float64| DOUBLE |
|String       | String|Utf8 | VARCHAR, CHAR, TEXT, STRING|
|Timestamp    | SystemTime|Timestamp| TIMESTAMP|
|Bytes        | Vec<u8\>|Binary| BYTEA|

## DDL Semantics
### CREATE TABLE
Arroyo's CREATE TABLE statements come in three flavors: Create Table As, Memory Table and Connection Table.
#### CREATE TABLE AS
This comamnd creates a table from the query included in it, e.g.
```sql
CREATE TABLE orders AS SELECT customer_id, order_id FROM orders;
```
The schema is inferred from the query and other queries within the same context can read the new table.
#### CREATE TABLE (In-Memory)
CREATE TABLE statements without any connection info are presumed to be in memory.
It can be written to within the same query context and then read from. 
Currently you can only insert into a given memory table once, but multiple sources can then read from it.
For example, you could create an `orders` with a statement like
```sql
CREATE TABLE orders (customer_id INT, order_id INT);
```
At present, `CREATE VIEW` is simply an alias for creating a memory table.
#### CREATE TABLE (Connection)
If you want to read or write using a pre-defined connection 
this is done by including a WITH clause in the CREATE TABLE statement. 
This should include the connection name and any other arguments needed to instantiate the connection,
such as the kafka topic. For example, i you have a kafka connection my_kafka and want to output to order_topic, 
you could write
```sql
CREATE TABLE orders (
  customer_id INT,
  order_id INT)
 WITH (
  connection='my_kafka',
  topic='order_topic');
```
### INSERT INTO
Arroyo supports INSERT INTO statements for both memory and connection tables.
In line with standard SQL the insertion will happen column-wise,
 attempting coercion to the SQL types.
For example, if you have a memory table `orders` with columns `customer_id` and `order_id`
you could insert into it with a statement like
```sql
INSERT INTO orders SELECT customer, order FROM source_table;
```
If the table is a connection table this will result in a sink,
otherwise it will be a memory table that can then be read from.

## Joins

Arroyo supports two kinds of joins: Windowed Joins and Joins with Expiration.
### Windowed Joins
Windowed joins are joins over some windowing strategy. Currently windows require some aggregate, 
e.g. `GROUP BY`.
 Arroyo tracks every stage of the query plan to determine whether the output data has been windowed.
If so, future windows will just persist the window, joining data with equal windows.
Currently joining differently shaped windows or rolling up a window into a larger window is unsupported.

### Joins with Expiration
Joins without windows have an implicit expiration time, 
currently with a default value of one day (see issue [117](https://github.com/ArroyoSystems/arroyo/issues/117)).
Because Arroyo doesn't support updating streams ([118](https://github.com/ArroyoSystems/arroyo/issues/118)), 
only inner joins are supported.

### Nullity
Arroyo tracks the nullability of all expressions and fields. 
Sources and sinks are expected to specify if each field can be null.
If a field is non-null and missing, the pipeline will fail.

For the builtin SQL functions Arroyo follows the Postgres semantics for nullity.
In general, a function can only have a null output if one of the arguments is null,
however there are some exceptions, such as the `NULLIF` function.


## Supported SQL Functions

Arroyo supports a subset of the Postgres SQL functions. 
PR's to expand this set are welcome. 
The builtin functions match the behavior defined in DataFusion [here](https://arrow.apache.org/datafusion/user-guide/sql/scalar_functions.html).

### Math Functions
Unsupported functions: `random()`, `pi()`, `radians()`, `power()`, `atan2()`, `cbrt()`.

### String Functions
Unsupported functions: `to_hex()`, `uuid()`. 

### Regular Expression Functions
Unsupported functions: `regexp_matches()`, `regexp_replace()`.

### Date/Time Functions
Unsupported functions: `now()`, `current_date()`, `current_time()`, `date_bin()`, `date_trunc()`, `datetrunc()`, `date_part()`,
`extract()`, `to_timestamp()`, `to_timestamp_millis()`, `to_timestamp_micros()`, `to_timestamp_seconds()`, `from_unixtime()`.

### Aggregate functions
Arroyo currently supports the following aggregate functions: `count()`, `sum()`, `avg()`, `min()`, `max()`, as well as the distinct version of count. 
Extending this to other aggregates will generally require implementing an efficient algorithm. Contributions are welcome.